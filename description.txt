E 55 => State: dar class component ha vojod darad va b jaye props baraye meghdar dehi mojadad estefadte mishavad, ma mitavanim har property digari b jaye state estefadte konim vali dar bahse reRender faght ba taghir state code haye ma rerender mishavand.



جلسه 57 - بخش ایونت => ما در کلاس کامپوننت ها هر ایونتی که روی باکس خود ست کنیم و سپس هندلر آن را مینویسیم، ابتدا از طریق استیتی که قبلا در کانستراکتور تعریف کرده ایم، مقدار پراپرتی مد نظر خود را تغییر دادع و سپس استیت را به متد ست استیت پاس میدهیم تا باکسمان ریرندر شود.
دقت کنیم که هنگام پاس دادن تابع ایونت، حتما استیت یا دیس -منطور همان کلاس است- را بایند کنیم. در غیر این صورت دیس معنی آندیف خواهد داد.


key in map item => باید حین رندر کردن لیستی از ایتم ها، حتما به هر کدام از انها کی بدهیم و مقدار آن نیز باید یونیک باشد به همین دلیل باید برای آبجکت مخصوص آن ایتم، یک ای دی بزاریم و هرگز از ایندکس ایتم استفاده نکنیم زیرا ممکن است با حذف یا اضافه شدن آیتمی، مقدار کی ما تغییر کند و کنترل آیتم ها برای ریکت سخت شود.


forms => ما در کلاس کامپوننت ها برای هر اینپوت باید در استیت یک ولیو در نظر بگیریم.


*** ما علاوه بر استرینگ و نامبر و ...، میتوانیم یک متد را به عنوان ولیوی یک اتریبیوت در نظر بگیریم و آن را برای کامپوننت مورد نظر ارسال کنیم. --همانند کال بک فانکشن در نظر بگیر--ئ


Fragment = > اگر میخواهیم در کامپوننت خود هیچ تگ نگهدارنده ای نباشد، از فرگمنت استفاده میکنیم که از پکیج ریکت ایمپورت میشود یا اصلا میتوانیم تگ نگه دارنده را خالی بگذاریم که باز هم همان مفهوم را خواهد داشت .

life cycle = > هر کامپوننتی یک چرخه حیات دارد که شامل سه بخش mounting , updaating , unmounting میباشد .

در حین رخ دادن هر کدام از سه بخش بالا یعنی تولد ، اپدیت شدن و مردن کامپوننت یک تابع در کلاس کامپوننت ها اجرا میشود.

componentDidMount()
componentDidUpdate()
componentWillUnmount()


** Mounting

* اولین تابعی که حین تولد کامپوننت اجرا میشود، کانستراکتور است و به همین دلیل ما استیت ها را در انجا تعریف میکنیم.

پس از آن تابع 
static getDerivedStateFromProps(props,state){
    return {
        stete property ...
    }
}

تابع بالا برای ست کردن پراپس ها به عنوان استیت به کار گرفته میشود ولی کاربرد چندانی ندارد.

پس از تابع بالا ، تابع رندر و سپس کامپوننت دید مونت اجرا میشود.

** دقت شود هنگامی که تابع رندر به صورت کامل اجرا شد یعنی کامپوننت های فراخوانی شده داخل آن و تمامی توابع کامپوننت های داخلی اجرا شد، پس از آن تابع دید مونت اجرا میشود. نکته مهم تر این است که تابع دید مونت فقط یک بار اجرا میشه ولی رندر با اپدیت شدن هم اجرا میشه.

این تابع در مباحث ای جکس و اتصال به سرور کاربردی است.

updaating

آپدیت وقتی رخ میده که استیت یا پراپ های یک کامپوننت تغییر کنه . البته پراپ ها به خودی خود تغییر نمیکنه مگر اینکه کامپوننت داخلی باشه و ریرندر بشه.

ابتدا تابع 
getDerivedStateFromProps(props, state) 
اجرا میشه.
سپس تابع 
shouldComponentUpdate
که ترو یا فالس را ریترن میکند. اگر ترو را ریترن کند پس از آن تابع رندر اجرا میشود و اگر فالس بده تابع رندر اجرا نمیشه.

مثلا اگر بخواهیم تغییر کوچکی در کامپوننت بدهیم و سایر کامپوننت های داخلی آن که ربطی به موضوع ندارند رندر شوند ، اصلا بهینه نیست بنابراین با توجه به تغییری که رخ میدهد باید شرط بزاریم که کامپوننت داخلی رندر بشه یا نشه.

ب جای شولد کامپوننت میتوانیم به جای فراخوانی کامپوننت ، پیور کامپوننت را فراخوانی کنیم.


getSnapshotBeforeUpdate(props, state)
پس از رندر شدن کامل آپدیت کامپوننت، این تابع اجرا خواهد شد. تفاوت پراپرس و استیت آن با تابع گت دریود استیت در این است که این تابع پراپس و استیت های قبل از آپدیت را نشان میدهد. همچنین یک ولیو ریترن میکند که آن را به عنوان ورودی به تابع کامپوننت دید آپدیت پاس میدهیم.

componentDidUpdate(props, state, data)
برای تابع بالا  هم دقیقا استیت ها قبل از اپدیت هستن.



const [stateName,setStateName] = useState(value)

setStateName(newValue) : new value for stateName

useEffect(() => {
    mount
    return ()=>{
        unmount
    }
  }, []);


useEffect(() => {
    update with all state
  });

useEffect(() => {
    update with stateName
  },[stateName]);

 ** ابتدا رندر میشه سپس ماونت و سپس آپدیت اتفاق میفته.مثلا اگر متغیری ست استیت شد، مقدار آن در همان لحظه تغییر نخواهد کرد بلکه ابتدا رندر اتفاق افتاده و سپس مقدارش تغییر میکند پس برای دسترسی به مقدار جدید از یوز افکت آپدیت استفاده میکنیم به این دلیل که آپدیت بعد از رندر اتفاق افتاده و ما به مقدار جدید متغیر دسترسی خواهیم داشت.


 mpa => لایف سایکل آن به این صورت است که برای دریافت هر اطلاعاتی از سمت سرور، صفحه باید یک بار رفرش شود.

 spa => لایف سایکل آن به این صورت است که برای دریافت هر اطلاعاتی از سمت سرور، صفحه نیازی نیست که رفرش شود و به صورت ایجکس اطلاعات را از بکند میگیریم.


 route => کد های فایل پروداکتس مطالعه شود.

 ** تفاوت نولینک با لینک اینه که تو نو لینک میشه فهمید که آیا در یوارال ، پث مربوط به اون المنت هست یا نه - یعنی فعاله یا نه -
 isActive in className

 ** اگر با رخ دادن ایونتی ست استیت کنیم و در پی آن از یوز افکت بهره ببریم مثلا برای گرفتن دیتا از بک اند ، در این حالت باید یک ست استیت در یوز افکت تنظیم کنبم تا کامپوننت ب شکل ریل تایم رندر شود.


 useMemo = > ورودی آن تابعی است که یک خروجی دارد ولی ما نمیخواهیم با هر بار رندر شدن کامپوننت آن تابع اجرا بشه بلکه فقط با تغییر استیتی خاص میخواهیم آن خروجی خود را نشان دهد  پس در ورودی دوم لیستی از استیت هایی که با تغییر کردن آن ها میخواهیم خروجی به دست بیاید را مشخص میکنیم؛ ما آن خروجی را در یک متغیر ذخیره میکنیم.

 مثلا لیستی از نوت ها یا یوزر ها داریم و هنگام تایپ در اینپوت و با رندر شدن کامپوننت، مدام روی لیست کاربر ها مپ اجرا میشود. در صورتی که ما فقط میخواهیم حین تغییر استیت لیست کاربر روی آنها مجددا مپ اجرا شود. در همچین حالتی از ممو استفاده میکنیم.



memo => یک های اردر کامپوننت است. یعنی یک کامپوننت را به عنوان ورودی دریافت میکند و کامپوننتی را به عنوان خروجی برمیگرداند. کارش دقیقا مثل یوز ممو است یعنی فقط در شرایط لازم از جمله رخ دادن ایونت، کامپوننت مد نظر را ری رندر میکند که البته باید حواسمان به رفرنس تایپ بودن توابع هم باشد که الان آن را بررسی میکنیم.



 useCallback = > گاهی اوقات ممکن است خروجی ممو یک کامپوننت باشد که میخواهیم ایونتی را برای آن ست کنیم. پس باید یک تابع ایونت را برای آن ارسال کنیم. اما دقت کنیم که توابع رفرنس تایپ هستند و پس از رندر شدن کامپوننت، تابع مد نظر فضای جدیدی از حافظه را اشغال میکند؛ پس لازم است برای جلوگیری از این اتفاق، تابع مد نظر را به کال بک بدهیم و در ورودی دوم آن استیتی که با تغییر آن ، تابع مد نظر ما ذخیره خواهد شد را پاس میدهیم.


 ** یوز ممو نمیتواند یک تاپ لول-یعنی تابع بالاتر از خود را ریترن کند و فقط بدنه تاپ لول که شامل یک ولیو میشود را میتواند ریترن کند. برای اون کار از ممو استفاده میکنیم.

 ** از یوز ممو در کامپوننت هایی با عملکرد سنگین استفاده میشه مثلا لیست سنگینی از کاربر یا فلان ولی از یوز کال بک برای توابعی که برای چایلد های یک کامپوننت میفرستیم مانند ایونت هندلر ها استفاده میشه.



 useRef => دو کاربرد دارد. کاربرد اول مربوط به انتخاب المنت از دام مجازی است به این صورت که یک متغیر تعریف میکنیم و مقدار ان را یوز رف میزاریم و بعد پراپرتی رف را در المنت مد نظر تعریف میکنیم و مقدار آن را اسم متغیر تعریف میکنیم. در این حالت ما میتوانیم هر بلایی که میخوایم سر المنت بیاریم.

 کاربرد دوم آن شبیه استیت هاست. یعنی میتوانیم یک متغیر تعریف کنیم و مقدار آن را در یوز رف نگه داریم و سپس آن را تغییر دهیم بدون آنکه کامپوننت ما ری رندر شود.